# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/153Znej44tSneSC62-zshXY-Vab-1NH_v
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

import torch
import torch.nn as nn
from torch.utils.data import DataLoader, Dataset

import numpy as np
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_absolute_percentage_error, mean_squared_error

df = pd.read_excel('all.xlsx')


print(df.head())

plt.figure(figsize=(14,5))
plt.plot(df['Data'], df['V'], label='Потребление газа (V)', color='blue')
plt.title('Потребление газа по времени')
plt.xlabel('Дата')
plt.ylabel('Объем потребления газа')
plt.grid(True)
plt.legend()
plt.show()

plt.figure(figsize=(8,6))
plt.scatter(df['T'], df['V'], alpha=0.6, color='green')
plt.title('Потребление газа в зависимости от температуры')
plt.xlabel('Температура, °C')
plt.ylabel('Объем потребления газа')
plt.grid(True)
plt.show()

"""Снижение температуры → увеличение потребления

"""

df_2015 = df[df['Data'].dt.year == 2015]

# Построение графика
plt.figure(figsize=(14,5))
plt.plot(df_2015['Data'], df_2015['V'], label='Потребление газа (V) — 2015', color='blue')
plt.title('Потребление газа по времени (2015 год)')
plt.xlabel('Дата')
plt.ylabel('Объем потребления газа')
plt.grid(True)
plt.legend()
plt.show()

df['month'] = df['Data'].dt.month

plt.figure(figsize=(10,6))
df.boxplot(column='V', by='month', grid=False)
plt.title('Распределение потребления газа по месяцам')
plt.suptitle('')
plt.xlabel('Месяц')
plt.ylabel('Объем потребления газа')
plt.show()

df['month'] = pd.to_datetime(df['Data']).dt.month

def get_season(month):
    if month in [12, 1, 2]:
        return 0  # Зима
    elif month in [3, 4, 5]:
        return 1  # Весна
    elif month in [6, 7, 8]:
        return 2  # Лето
    else:
        return 3  # Осень

df['season'] = df['month'].apply(get_season)


df['is_winter'] = (df['season'] == 0).astype(int)
df['is_spring'] = (df['season'] == 1).astype(int)
df['is_summer'] = (df['season'] == 2).astype(int)
df['is_autumn'] = (df['season'] == 3).astype(int)


df['is_workday']   = (df['id'] == 0).astype(int)
df['is_weekend']   = (df['id'] == 1).astype(int)
df['is_shortday']  = (df['id'] == 2).astype(int)
df['is_holiday']   = (df['id'] == 3).astype(int)


df['V_target'] = df['V'].shift(-2)


df['T_t+1'] = df['T'].shift(-1)
df['T_t+2'] = df['T'].shift(-2)
df['T_t+3'] = df['T'].shift(-3)

df['dayofyear'] = pd.to_datetime(df['Data']).dt.dayofyear


df['sin_dayofyear'] = np.sin(2 * np.pi * df['dayofyear'] / 365)
df['cos_dayofyear'] = np.cos(2 * np.pi * df['dayofyear'] / 365)


df = df.drop(columns=['id', 'season'])


df_model = df.dropna().reset_index(drop=True)

df_model

import random
import numpy as np
import torch

def set_seed(seed=42):
    random.seed(seed)
    np.random.seed(seed)
    torch.manual_seed(seed)
    torch.cuda.manual_seed_all(seed)
    torch.backends.cudnn.deterministic = True
    torch.backends.cudnn.benchmark = False

set_seed(42)

data = df_model.copy()


target_col = 'V_target'


features = [col for col in data.columns if col not in ['Data', 'V_target']]


scaler_X = MinMaxScaler()
scaler_y = MinMaxScaler()

X_scaled = scaler_X.fit_transform(data[features])
y_scaled = scaler_y.fit_transform(data[[target_col]])


seq_len = 7


X_seq = []
y_seq = []

for i in range(seq_len, len(X_scaled)):
    X_seq.append(X_scaled[i-seq_len:i])
    y_seq.append(y_scaled[i])

X_seq = np.array(X_seq)
y_seq = np.array(y_seq)

class GasDataset(Dataset):
    def __init__(self, X, y):
        self.X = torch.tensor(X, dtype=torch.float32)
        self.y = torch.tensor(y, dtype=torch.float32)

    def __len__(self):
        return len(self.X)

    def __getitem__(self, idx):
        return self.X[idx], self.y[idx]


train_size = int(len(X_seq) * 0.97)
X_train, X_test = X_seq[:train_size], X_seq[train_size:]
y_train, y_test = y_seq[:train_size], y_seq[train_size:]


train_dataset = GasDataset(X_train, y_train)
test_dataset = GasDataset(X_test, y_test)

train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)
test_loader = DataLoader(test_dataset, batch_size=32, shuffle=False)

class RNNModel(nn.Module):
    def __init__(self, input_size, hidden_size=64, num_layers=2):
        super(RNNModel, self).__init__()
        self.rnn = nn.RNN(input_size, hidden_size, num_layers, batch_first=True)
        self.fc = nn.Linear(hidden_size, 1)

    def forward(self, x):
        out, _ = self.rnn(x)
        out = out[:, -1, :]
        out = self.fc(out)
        return out

model = RNNModel(input_size=X_train.shape[2])
criterion = nn.MSELoss()
optimizer = torch.optim.Adam(model.parameters(), lr=0.001)

num_epochs = 50
for epoch in range(num_epochs):
    model.train()
    total_loss = 0
    for X_batch, y_batch in train_loader:
        optimizer.zero_grad()
        outputs = model(X_batch).squeeze()
        loss = criterion(outputs, y_batch.squeeze())
        loss.backward()
        optimizer.step()
        total_loss += loss.item()

    if epoch % 10 == 0 or epoch == num_epochs - 1:
        print(f"Epoch {epoch+1}/{num_epochs}, Loss: {total_loss:.4f}")

model.eval()
with torch.no_grad():
    preds = []
    true = []
    for X_batch, y_batch in test_loader:
        output = model(X_batch).squeeze()
        preds.append(output.numpy())
        true.append(y_batch.squeeze().numpy())


y_pred_r = scaler_y.inverse_transform(np.concatenate(preds).reshape(-1, 1)).flatten()
y_true_r= scaler_y.inverse_transform(np.concatenate(true).reshape(-1, 1)).flatten()


mape = mean_absolute_percentage_error(y_true_r, y_pred_r) * 100
rmse = np.sqrt(mean_squared_error(y_true_r, y_pred_r))

print(f" MAPE: {mape:.2f}%")
print(f" RMSE: {rmse:.2f}")

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np


test_dates = df_model['Data'][-len(y_true_r):].reset_index(drop=True)


results_df = pd.DataFrame({
    'Date': pd.to_datetime(test_dates),
    'Actual': y_true_r,
    'Predicted': y_pred_r
})


plt.figure(figsize=(14, 6))
plt.plot(results_df['Date'], results_df['Actual'], label='Actual', linewidth=2)
plt.plot(results_df['Date'], results_df['Predicted'], label='Predicted', linewidth=2)
plt.title('Прогноз потребления газа (через 3 дня)')
plt.xlabel('Дата')
plt.ylabel('Потребление газа')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

y_true_r

y_pred_r

"""FNN"""

df = pd.read_excel('all.xlsx')

df['month'] = df['Data'].dt.month
df['month'] = pd.to_datetime(df['Data']).dt.month

def get_season(month):
    if month in [12, 1, 2]:
        return 0  # Зима
    elif month in [3, 4, 5]:
        return 1  # Весна
    elif month in [6, 7, 8]:
        return 2  # Лето
    else:
        return 3  # Осень

df['season'] = df['month'].apply(get_season)


df['is_winter'] = (df['season'] == 0).astype(int)
df['is_spring'] = (df['season'] == 1).astype(int)
df['is_summer'] = (df['season'] == 2).astype(int)
df['is_autumn'] = (df['season'] == 3).astype(int)


df['is_workday']   = (df['id'] == 0).astype(int)
df['is_weekend']   = (df['id'] == 1).astype(int)
df['is_shortday']  = (df['id'] == 2).astype(int)
df['is_holiday']   = (df['id'] == 3).astype(int)


df['V_target'] = df['V'].shift(-3)


df['T_t+1'] = df['T'].shift(-1)
df['T_t+2'] = df['T'].shift(-2)
df['T_t+3'] = df['T'].shift(-3)

df['dayofyear'] = pd.to_datetime(df['Data']).dt.dayofyear


df['sin_dayofyear'] = np.sin(2 * np.pi * df['dayofyear'] / 365)
df['cos_dayofyear'] = np.cos(2 * np.pi * df['dayofyear'] / 365)


df = df.drop(columns=['id', 'season'])


df_model = df.dropna().reset_index(drop=True)
data = df_model.copy()


target_col = 'V_target'

import pandas as pd
import numpy as np
import torch
from torch import nn
from torch.utils.data import DataLoader, Dataset
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_absolute_percentage_error, mean_absolute_error, mean_squared_error

# Создаем копию
df_nn = df_model.copy()

df_nn = df_model.copy()

# Сначала создаем лаги
df_nn['V_t-1'] = df_nn['V'].shift(1)
df_nn['V_t-2'] = df_nn['V'].shift(2)
#df_nn['V_t-3'] = df_nn['V'].shift(3)
#df_nn['V_t-4'] = df_nn['V'].shift(4)
df_nn['T_t-1'] = df_nn['T'].shift(1)
df_nn['T_t-2'] = df_nn['T'].shift(2)
#df_nn['T_t-3'] = df_nn['T'].shift(3)
#df_nn['T_t-4'] = df_nn['T'].shift(4)


df_nn['V_target'] = df_nn['V'].shift(-3)

df_nn = df_nn.dropna().reset_index(drop=True)


features = [col for col in df_nn.columns if col not in ['Data', 'V_target']]


scaler_X = MinMaxScaler()
scaler_y = MinMaxScaler()

X_scaled = scaler_X.fit_transform(df_nn[features])
y_scaled = scaler_y.fit_transform(df_nn[[target_col]])


split = int(len(X_scaled) * 0.97)
X_train, X_test = X_scaled[:split], X_scaled[split:]
y_train, y_test = y_scaled[:split], y_scaled[split:]

class GasFNNData(Dataset):
    def __init__(self, X, y):
        self.X = torch.tensor(X, dtype=torch.float32)
        self.y = torch.tensor(y, dtype=torch.float32)

    def __len__(self):
        return len(self.X)

    def __getitem__(self, idx):
        return self.X[idx], self.y[idx]

train_data = GasFNNData(X_train, y_train)
test_data = GasFNNData(X_test, y_test)

train_loader = DataLoader(train_data, batch_size=32, shuffle=True)
test_loader = DataLoader(test_data, batch_size=32, shuffle=False)

class FNNModel(nn.Module):
    def __init__(self, input_size):
        super(FNNModel, self).__init__()
        self.model = nn.Sequential(
            nn.Linear(input_size, 64),
            nn.ReLU(),
            nn.Linear(64, 32),
            nn.ReLU(),
            nn.Linear(32, 1)
        )

    def forward(self, x):
        return self.model(x)

model = FNNModel(input_size=X_train.shape[1])
criterion = nn.MSELoss()
optimizer = torch.optim.Adam(model.parameters(), lr=0.0001)

epochs = 250
for epoch in range(epochs):
    model.train()
    total_loss = 0
    for xb, yb in train_loader:
        optimizer.zero_grad()
        out = model(xb).squeeze()
        loss = criterion(out, yb.squeeze())
        loss.backward()
        optimizer.step()
        total_loss += loss.item()

    if epoch % 10 == 0 or epoch == epochs - 1:
        print(f"Epoch {epoch+1}/{epochs}, Loss: {total_loss:.4f}")

model.eval()
with torch.no_grad():
    preds, true = [], []
    for xb, yb in test_loader:
        out = model(xb).squeeze()
        preds.append(out.numpy())
        true.append(yb.squeeze().numpy())


y_pred_n = scaler_y.inverse_transform(np.concatenate(preds).reshape(-1, 1)).flatten()
y_true_n = scaler_y.inverse_transform(np.concatenate(true).reshape(-1, 1)).flatten()


mape = mean_absolute_percentage_error(y_true_n, y_pred_n) * 100
rmse = np.sqrt(mean_squared_error(y_true_n, y_pred_n))

print(f"MAPE: {mape:.2f}%")
print(f"RMSE: {rmse:.2f}")

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np


test_dates = df_model['Data'][-len(y_true_n):].reset_index(drop=True)


results_df = pd.DataFrame({
    'Date': pd.to_datetime(test_dates),
    'Actual': y_true_n,
    'Predicted': y_pred_n
})


plt.figure(figsize=(14, 6))
plt.plot(results_df['Date'], results_df['Actual'], label='Actual', linewidth=2)
plt.plot(results_df['Date'], results_df['Predicted'], label='Predicted', linewidth=2)
plt.title('Прогноз потребления газа (через 3 дня)')
plt.xlabel('Дата')
plt.ylabel('Потребление газа')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

import xgboost as xgb
from sklearn.metrics import mean_squared_error, mean_absolute_error, mean_absolute_percentage_error


model_xgb = xgb.XGBRegressor(n_estimators=100, max_depth=3, learning_rate=0.1)
model_xgb.fit(X_train, y_train.ravel())

y_pred_xgb = model_xgb.predict(X_test)


y_pred_xgb = scaler_y.inverse_transform(y_pred_xgb.reshape(-1, 1)).flatten()
y_true = scaler_y.inverse_transform(y_test).flatten()


mape = mean_absolute_percentage_error(y_true, y_pred_xgb) * 100
rmse = np.sqrt(mean_squared_error(y_true, y_pred_xgb))

print(f"XGBoost → MAPE: {mape:.2f}%, RMSE: {rmse:.2f}")

import numpy as np
from sklearn.metrics import mean_absolute_percentage_error, mean_squared_error



model.eval()
with torch.no_grad():
    preds = []
    for xb, _ in test_loader:
        out = model(xb).squeeze().numpy()
        preds.append(out)


y_pred_fnn = np.concatenate(preds).reshape(-1, 1)
y_pred_fnn = scaler_y.inverse_transform(y_pred_fnn).flatten()


y_pred_ensemble = (y_pred_fnn + y_pred_xgb) / 2


y_true = scaler_y.inverse_transform(y_test).flatten()

mape = mean_absolute_percentage_error(y_true, y_pred_ensemble) * 100
rmse = np.sqrt(mean_squared_error(y_true, y_pred_ensemble))

print(f"MAPE: {mape:.2f}%")
print(f"RMSE: {rmse:.2f}")

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

test_dates = df_model['Data'][-len(y_true):].reset_index(drop=True)


results_df = pd.DataFrame({
    'Date': pd.to_datetime(test_dates),
    'Actual': y_true,
    'Predicted': y_pred_ensemble
})


plt.figure(figsize=(14, 6))
plt.plot(results_df['Date'], results_df['Actual'], label='Actual', linewidth=2)
plt.plot(results_df['Date'], results_df['Predicted'], label='Predicted', linewidth=2)
plt.title('Прогноз потребления газа (через 3 дня)')
plt.xlabel('Дата')
plt.ylabel('Потребление газа')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

"""FCNN"""

import torch
from torch import nn
from torch.utils.data import Dataset, DataLoader

# Целевой столбец
target_col = 'V_target'

# Dataset
class GasDataset(Dataset):
    def __init__(self, X, y):
        self.X = torch.tensor(X, dtype=torch.float32)
        self.y = torch.tensor(y, dtype=torch.float32)

    def __len__(self):
        return len(self.X)

    def __getitem__(self, idx):
        return self.X[idx], self.y[idx]

# DataLoaders
train_dataset = GasDataset(X_train, y_train)
test_dataset = GasDataset(X_test, y_test)

train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)
test_loader = DataLoader(test_dataset, batch_size=32, shuffle=False)

class FullyConnectedNN(nn.Module):
    def __init__(self, input_dim):
        super(FullyConnectedNN, self).__init__()
        self.net = nn.Sequential(
            nn.Linear(input_dim, 64),
            nn.ReLU(),
            nn.Linear(64, 32),
            nn.ReLU(),
            nn.Linear(32, 1)
        )

    def forward(self, x):
        return self.net(x)

model = FullyConnectedNN(X_train.shape[1])
loss_fn = nn.MSELoss()
optimizer = torch.optim.Adam(model.parameters(), lr=0.001)

# Обучение
for epoch in range(100):
    model.train()
    for X_batch, y_batch in train_loader:
        optimizer.zero_grad()
        preds = model(X_batch).squeeze()
        loss = loss_fn(preds, y_batch.squeeze())
        loss.backward()
        optimizer.step()

    if epoch % 10 == 0:
        print(f"Epoch {epoch} | Loss: {loss.item():.5f}")

model.eval()
y_preds = []
y_true = []

with torch.no_grad():
    for X_batch, y_batch in test_loader:
        preds = model(X_batch).squeeze()
        y_preds.append(preds.numpy())
        y_true.append(y_batch.squeeze().numpy())

# Склеим все предсказания
y_preds = np.concatenate(y_preds)
y_true = np.concatenate(y_true)

# Обратное масштабирование
y_preds_inv = scaler_y.inverse_transform(y_preds.reshape(-1, 1)).flatten()
y_true_inv = scaler_y.inverse_transform(y_true.reshape(-1, 1)).flatten()

# Метрики
rmse = np.sqrt(mean_squared_error(y_true_inv, y_preds_inv))
mape = mean_absolute_percentage_error(y_true_inv, y_preds_inv)
print(f"MAPE: {mape * 100:.2f}%")
print(f"RMSE: {rmse:.3f}")

"""prophet"""

import pandas as pd
from prophet import Prophet
from sklearn.metrics import mean_absolute_percentage_error, mean_squared_error
import numpy as np

# Копия и подготовка
df_prophet = df_model[['Data', 'V_target']].copy()
df_prophet.rename(columns={'Data': 'ds', 'V_target': 'y'}, inplace=True)

# Удалим пропуски
df_prophet = df_prophet.dropna().reset_index(drop=True)

# Разделение на train/test (последние 3 месяца = тест)
cutoff_date = df_prophet['ds'].max() - pd.Timedelta(days=113)
train_df = df_prophet[df_prophet['ds'] <= cutoff_date]
test_df = df_prophet[df_prophet['ds'] > cutoff_date]

# Создание и обучение модели Prophet
model = Prophet(
    daily_seasonality=True,
    yearly_seasonality=True,
    weekly_seasonality=True
)
model.fit(train_df)

# Прогнозируем на длину теста (90 дней)
future = model.make_future_dataframe(periods=len(test_df), freq='D')
forecast = model.predict(future)

# Объединим прогноз и тест
pred_df = forecast[['ds', 'yhat']].merge(test_df, on='ds', how='inner')

# Метрики
mape = mean_absolute_percentage_error(pred_df['y'], pred_df['yhat']) * 100
rmse = np.sqrt(mean_squared_error(pred_df['y'], pred_df['yhat']))

print(f'MAPE: {mape:.2f}%')
print(f'RMSE: {rmse:.2f}')

model.plot(forecast)

from prophet import Prophet
from sklearn.metrics import mean_absolute_percentage_error, mean_squared_error
import numpy as np
import pandas as pd

# Выбираем нужные столбцы
df_prophet = df_model[['V',	'T',
    'Data', 'V_target',
    'T_t+1', 'T_t+2', 'T_t+3','is_workday',	'is_weekend', 'is_shortday',	'is_holiday'
]].copy()

# Переименуем
df_prophet.rename(columns={'Data': 'ds', 'V_target': 'y'}, inplace=True)
df_prophet = df_prophet.dropna()

# Инициализация модели

model = Prophet(
    interval_width=0.95,
    changepoint_prior_scale=0.01,
    seasonality_prior_scale=0.01,
    holidays_prior_scale=1.0,
    yearly_seasonality=True,
    weekly_seasonality=True,
    daily_seasonality=False,
    seasonality_mode='multiplicative'


)

#model.add_country_holidays(country_name='RU')
# Добавляем регрессоры
regressors = ['V',	'T','T_t+1', 'T_t+2', 'T_t+3','is_workday',	'is_weekend', 'is_shortday',	'is_holiday']
for reg in regressors:
    model.add_regressor(reg)

# Train/test split
cutoff_date = df_prophet['ds'].max() - pd.Timedelta(days=113)
train_df = df_prophet[df_prophet['ds'] <= cutoff_date]
test_df = df_prophet[df_prophet['ds'] > cutoff_date]

# Обучение модели
model.fit(train_df[['ds', 'y'] + regressors])

# Подготовка future с теми же регрессорами
future = test_df[['ds'] + regressors]

# Прогноз
forecast = model.predict(future)

# Сравнение
pred_df = forecast[['ds', 'yhat']].merge(test_df[['ds', 'y']], on='ds')
mape = mean_absolute_percentage_error(pred_df['y'], pred_df['yhat']) * 100
rmse = np.sqrt(mean_squared_error(pred_df['y'], pred_df['yhat']))

print(f'MAPE: {mape:.2f}%')
print(f'RMSE: {rmse:.2f}')

# Прогноз
forecast = model.predict(future)

# Оценка попадания в интервал
interval_df = forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].merge(test_df[['ds', 'y']], on='ds')
interval_df['in_interval'] = (interval_df['y'] >= interval_df['yhat_lower']) & (interval_df['y'] <= interval_df['yhat_upper'])

coverage = interval_df['in_interval'].mean() * 100

print(f"Доля попаданий в интервал (95% доверительный): {coverage:.2f}%")

import matplotlib.pyplot as plt
# Добавим реальные значения в forecast
forecast = forecast.merge(test_df[['ds', 'y']], on='ds', how='left')

plt.figure(figsize=(12,6))

# Рисуем реальные значения
plt.plot(forecast['ds'], forecast['y'], label='Реальные значения', color='black')

# Рисуем прогноз
plt.plot(forecast['ds'], forecast['yhat'], label='Прогноз', color='blue')

# Заполняем область доверительного интервала
plt.fill_between(forecast['ds'], forecast['yhat_lower'], forecast['yhat_upper'],
                 color='blue', alpha=0.3, label='Доверительный интервал')

plt.xlabel('Дата')
plt.ylabel('Значение')
plt.title('Прогноз и реальные значения с доверительным интервалом')
plt.legend()
plt.show()

print(forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper','y']].head(10))

# Убедимся, что длины совпадают
min_len = min(len(forecast), len(y_pred_r))

# Обрезаем до минимального размера
forecast_trimmed = forecast.iloc[:min_len].copy()
y_pred_r_trimmed = y_pred_r[:min_len]

import matplotlib.pyplot as plt

plt.figure(figsize=(12, 6))

# Реальные значения
plt.plot(forecast_trimmed['ds'], forecast_trimmed['y'], label='Реальные значения', color='black')

# Прогноз Prophet
plt.plot(forecast_trimmed['ds'], forecast_trimmed['yhat'], label='Прогноз Prophet', color='blue')

# Доверительный интервал Prophet
plt.fill_between(
    forecast_trimmed['ds'],
    forecast_trimmed['yhat_lower'],
    forecast_trimmed['yhat_upper'],
    color='blue', alpha=0.2,
    label='Интервал Prophet (95%)'
)

# Прогноз RNN
plt.plot(forecast_trimmed['ds'], y_pred_r_trimmed, label='Прогноз RNN', color='green', linestyle='--')

plt.xlabel('Дата')
plt.ylabel('Значение')
plt.title('Сравнение прогнозов: Prophet vs RNN')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

